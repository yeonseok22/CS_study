# 배열과 포인터
## 1차원 배열
- 배열을 사용해야 할 경우
  - 둘 이상의 동일한 Data Type 변수를 동시에 선언하는 효과를 지닌다.
  - 많은 양의 데이터를 일관적으로 처리해야 하는 경우에 유용하다.
  - 지역적 특성을 지닐 수도 있고, 전역적 특성을 지닐 수도 있다.
  - 배열 = Pointer라고 할 수 있을 정도로, 밀접한 관계를 가지고 있다.

- 배열 선언법 : ```자료형 배열_이름[배열_길이];```
- 문자열은 char(문자형 데이터)의 배열이다.
  - 특징 : 널(null) 문자를 끝에 지닌다.

- 널(null) 문자를 지녀야 하는 이유
  - 문자열의 끝을 표현하기 위해서
  - 쓰레기 값과 실제 문자열의 경계를 나타내기 위해
  - printf 함수는 널 문자를 통해서 출력의 범위를 결정짓는다.

- 문자열과 문자 배열의 차이점 : 문자열은 상수이지만, 문자 배열은 아니다.
  - ```char str[6] = "Hello";``` : 문자 배열(변수)
  - ```"Hello"``` : 문자열 (상수)
  - 문자열은 상수로 무조건 null을 붙여야 한다. 하지만 char형 배열은 그러한 문자열을 갖기 위한 배열로, null을 붙여도 되고 그러지 않아도 된다.


## 다차원 배열
- 다차원 배열 : 2차원 이상의 배열을 의미한다.
  - 수학적으론 n차원까지 있고, 컴퓨터는 256차원까지 사용이 가능하다.

- 2차원 배열 요소의 접근 방법
  ```C++
  int main(void)
  {
      int arr[3][3] = { {1, 2, 3}, {4, 5}, {6} };
      /*    2차원  - 초기값 : 0
         |1|2|3|
         |4|5|0|
         |6|0|0|
         
         실제 메모리 입력법
         |0x1000 ~ 0x1003|arr[0][0]|
         |0x1004 ~ 0x1007|arr[0][1]|
         |0x1008 ~ 0x100b|arr[0][2]|
         |0x100c ~ 0x100f|arr[1][0]|
         |0x1010 ~ 0x1013|arr[1][1]|
         |0x1014 ~ 0x1017|arr[1][2]|
         |0x1018 ~ 0x101b|arr[2][0]|
         |0x101c ~ 0x101f|arr[2][1]|
         |0x1020 ~ 0x1023|arr[2][2]|
      
      */
  }
  ```

- 다차원 배열 시, 주의할 사항
  - ```int arr[] = {1, 2, 3, 4, 5};``` : 1차원 배열 선언의 일반적인 방식
  - ```int arr[][] = {1, 2, 3, 4, 5, 6, 7, 8}; ``` : 컴파일러 오류 발생
  - ```int arr[][4] = {1, 2, 3, 4, 5, 6, 7, 8};``` : 가능
  - ```int arr[][2] = {1, 2, 3, 4, 5, 6, 7, 8};``` : 가능


## 다차원 배열과 포인터
- 포인터 = 주소를 가리키는 변수
- 참고 : 배열과 포인터는 같다.
  - ```*(a+2) == arr1[2]```
  - ```*(*(a+1)+2)) = arr2[1][2]```
- 모든 데이터는 주소가 부여되어 있다.
- 포인터도 변수이다. 변수의 한 종류.
  - 단지, 포인터라는 변수가 타입이 가지고 있는 것은 다른 변수의 주소를 가지고 있다는 것이다.

- 1차원 배열 이름의 포인터 타입 결정 포인트
  - 포인터가 가리키는 **요소의 자료형**
  - 포인터 연산 시 증가하는 바이트의 크기 : ```+```, ```++``, ```-```, ```--``` 가능하다.
  - 배열은 변수와 달리 casting에 의해 데이터 손실이 발생하지 않는다. 
    - 다만, 사용하는 주소값만 유지하게 되면 사실상 무관하게 된다.
  - 저장장소를 기록하는 주소가 있다. (주소를 다루는 변수 == 포인터)

- 1차원 배열 이름을 왜 포인터와 연결시키는 것인가??
  - 배열 이름이 곧 포인터이기 때문! => 그래서 포인터와 배열을 혼용해도 무방할 정도이다.
  - 배열 이름이 가리키는 요소의 자료형이 일치한다면, 포인터 연산 시 증가하는 값의 크기도 일치한다.
  - 따라서 1차원 배열 이름의 경우 가리키는 요소만 참조한다.

- 다차원 배열의 포인터 타입 결정 포인트
  - 포인터가 가리키는 요소의 자료형
  - 포인터 연산 시 증가하는 바이트의 크기

- 2차원 배열의 이름
  - 포인터가 가리키는 요소의 자료형이 같다고 하더라도 포인터 연산 시 증가하는 값의 크기는 불일치하다.
  - 포인터 연산 결과도 생각해 보아야 하낟.

- 매개변수로 선언되는 포인터의 또 다른 표현
  - ```void show_data(int (*ptr)[4], int a);``` == ```void show_data(int ptr[][4], int a);```

- ```int(*pArr)[4]```과 ```int *pArr[4]```의 차이점
  - ```int(*pArr)[4]``` : 포인터 배열로, | pArr[0], pArr[1], pArr[2], pArr[3] |를 나타낸다.
  - ```int *pArr[4]``` : 배열 포인터로, int arr[?][4] 배열의 요소를 가리킨다.

## 포인터 상세히
- 포인터와 포인터 변수
  - 메모리의 주소 값을 저장하기 위한 변수
  - "포인터"를 흔히 "포인터 변수"라고 한다.
  - 주소 값과 포인터는 다른 것!

- 그림을 통한 포인터의 이해
  - 컴퓨터의 주소 체계에 따라 크기가 결정된다.
  - 32bit 시스템 기반 -> 4byte
    - 메모리 관리 위해... 즉, 포인터 = 4byte

- 주소 관련 연산자
  - ```&``` 연산자 : 변수의 주소 값 반환
  - ```*``` 연산자 : 포인터가 가리키는 메모리 참조

- 포인터에 다양한 타입이 존재하는 이유 : 포인터 타입은 참조할 메모리의 크기 정보를 제공한다.
  ```C++
  // 예시
  #include <iostream>
  
  using namespace std;
  
  int main(void)
  {
      int a = 10;
      int *pA = &a;
      double e = 3.14;
      double *pE = &e;
      
      cout << *pA << " " << *pE << "\n";
      
      return 0;
  }
  ```
  
  ```C++
  #include <iosteam>
  
  using namespace std;
  
  int main(void)
  {
      /* 오류 사례 1
      int *pA;
      *pA = 10;   // 입력하는 것 자체만으로 오류가 발생할 수도 있다.
      */
      
      /* 오류 사례 2
      int *pA = 100;    // 100이 어디있음? (검증되고 제공된 주소를 대입해야 한다.)
      *pA = 10;
      */
  }
  ```

## 포인터와 배열
- 배열의 이름의 정체 : 배열 이름은 첫 번째 요소의 주소 값을 나타낸다.
- 배열 이름과 포인터 비교
  
  | 비교 조건 \ 비교 대상 | 포인터 | 배열 이름 |
  |:---:|:---:|:---:|
  |이름이 존재하는가|O|O|
  |무엇을 나타내는가|메모리의 주소|메모리의 주소|
  |변수인가 상수인가|변수|상수|
